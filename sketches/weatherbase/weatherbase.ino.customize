/* -------------------------------------------------------------------------------- 
 *  Weatherbase
 *  Harald Schlangmann, March 2021
 * -------------------------------------------------------------------------------- */

#include <Bolbro.h>
#include <BolbroWebServer.h>

#include <WeatherPacket.h>
#include <CalibrationPacket.h>
#include <HC12.h>

//  weather data

WeatherPacket weatherPacket;
time_t lastPacketUpdate = 0;

//  configuration data
CalibrationPacket calibrationPacket;

static void sendCalibration() {
  uint8_t *packetBinary = calibrationPacket.encodedBytes();
  int packetSize = calibrationPacket.encodedSize();
  
  if (DEBUG) {
    Serial.println("sending calibration...");
    calibrationPacket.printSerial();
  }
  
  HC12.write(packetBinary, packetSize);
}

//  web server

class WeatherWebServer:public BolbroWebServer
{
  public:

    WeatherWebServer() : BolbroWebServer () {
    }

    void begin() {

      //  static content
      on("/", [this]() { loadFromSpiffs("/index.html"); });
      on("/administration.html", [this]() { CHECKLOCALACCESS loadFromSpiffs("/administration.html"); });
      on("/BolbroHaus.jpg", [this]() { loadFromSpiffs("/BolbroHaus.jpg"); });
      on("/battery.png", [this]() { loadFromSpiffs("/battery.png"); });
      on("/humidity.png", [this]() { loadFromSpiffs("/humidity.png"); });
      on("/pressure.png", [this]() { loadFromSpiffs("/pressure.png"); });
      on("/temperature.png", [this]() { loadFromSpiffs("/temperature.png"); });
      on("/wind.png", [this]() { loadFromSpiffs("/wind.png"); });
      on("/updated.png", [this]() { loadFromSpiffs("/updated.png"); });
      on("/sun.png", [this]() { loadFromSpiffs("/sun.png"); });
      on("/rain.png", [this]() { loadFromSpiffs("/rain.png"); });

      //  dynamic stuff
      on("/weatherdata.json", [this]() { handleWeatherData(); });
      on("/calibrationdata.json", [this]() { handleCalibrationData(); });
      on("/change-calibration", [this]() { CHECKLOCALACCESS changeCalibration(); });
      on("/revert-calibration", [this]() { CHECKLOCALACCESS revertCalibration(); });
    
      BolbroWebServer::begin();    
    }
    
  private:
  
    void handleWeatherData() {
      String json = "{\n";
    
      json += "\t\"weather\" : " + weatherPacket.json("\t") + ",\n";
    
      if (lastPacketUpdate) {
        String timeStr(ctime(&lastPacketUpdate));
    
        json += "\t\"updated\" : \"" + timeStr.substring(0, timeStr.length()-1) + "\"\n";
      } else
        json += "\t\"updated\" : \"-\"\n";
    
      json += "}\n";
    
      send(200, "application/json", json);
      LOG->println("file /weatherdata.json generated and sent");
    }

    void handleCalibrationData() {
      String json = calibrationPacket.json();
    
      send(200, "application/json", json);
      LOG->println("file /calibrationdata.json generated and sent");
    }

    void revertCalibration() {
      Serial.println(messageToString());
      bool hadErrors = false;
      bool hadPassword = false;
      for (uint8_t i = 0; i < args(); i++) {
        if (argName(i)=="password") {
          hadErrors = hadErrors||arg(i)!=ADMINPASSWORD;
          hadPassword = true;
          LOG->printf("password: %s, hadErrors: %s\n", arg(i).c_str(), hadErrors?"true":"false");
        } else
          hadErrors = true;
      }
      
      if (hadErrors||!hadPassword)
        send(404, "text/plain", "invalid arguments");
      else {
        calibrationPacket.revertToDefaults();
        send(200, "text/plain", "OK");
      }
    }
    
    void changeCalibration() {
     Serial.println(messageToString());
     bool hadErrors = false;
      bool hadPassword = false;
      for (uint8_t i = 0; i < args(); i++) {
        if (argName(i)=="password") {
          hadErrors = hadErrors||arg(i)!=ADMINPASSWORD;
          hadPassword = true;
          LOG->printf("password: %s, hadErrors: %s\n", arg(i).c_str(), hadErrors?"true":"false");
        } else if (argName(i)=="speedFactor") {
          float newValue = arg(i).toFloat();
          if (newValue==0)
            hadErrors = true;
          else
            calibrationPacket.mWindSpeedFactor = newValue;
          LOG->printf("speedFactor: %.1f, hadErrors: %s\n", newValue, hadErrors?"true":"false");
        } else if (argName(i)=="height") {
          float newValue = arg(i).toFloat();
          if (newValue==0)
            hadErrors = true;
          else
            calibrationPacket.mMeasurementHeight = newValue;
          LOG->printf("height: %.2f, hadErrors: %s\n", newValue, hadErrors?"true":"false");
        } else if (argName(i)=="reportSecs") {
          unsigned long newValue = arg(i).toInt();
          if (newValue==0)
            hadErrors = true;
          else
            calibrationPacket.mSecondsBetweenReports = newValue;
          LOG->printf("reportSecs: %ld, hadErrors: %s\n", newValue, hadErrors?"true":"false");
        } else if (argName(i)=="bucketVol") {
          float newValue = arg(i).toFloat();
          if (newValue==0)
            hadErrors = true;
          else
            calibrationPacket.mBucketTriggerVolume = newValue;
          LOG->printf("bucketVol: %.2f, hadErrors: %s\n", newValue, hadErrors?"true":"false");
        } else
          hadErrors = true;
      }     

      if (hadErrors||!hadPassword)
        send(404, "text/plain", "invalid arguments");
      else {
        calibrationPacket.save();
        send(200, "text/plain", "OK");
      }
    }
};

WeatherWebServer server;

//  other functions
static void propagateToOpenHAB() {
  //  propagate verified data to openHAB
  if (weatherPacket.mTemperatureDegreeCelsius!=UNDEFINEDVALUE)
    Bolbro.updateItem("ESP32_Weatherbase_Temperature", String(weatherPacket.mTemperatureDegreeCelsius, 1)+"Â°C");
  if (weatherPacket.mAccumulatedRainMM!=UNDEFINEDVALUE)
    Bolbro.updateItem("ESP32_Weatherbase_SumRain", String(weatherPacket.mAccumulatedRainMM, 1)+"mm");
  if (weatherPacket.mPressureHPA!=UNDEFINEDVALUE)
    Bolbro.updateItem("ESP32_Weatherbase_Pressure", String(weatherPacket.mPressureHPA, 0)+"hPa");
  if (weatherPacket.mHumidityPercent!=UNDEFINEDVALUE)
    Bolbro.updateItem("ESP32_Weatherbase_Humidity", String(weatherPacket.mHumidityPercent, 1)+"%");
  if (weatherPacket.mWindDirection[0]!='\0')
    Bolbro.updateItem("ESP32_Weatherbase_WindAngle", String(weatherPacket.mWindDirection));
  if (weatherPacket.mWindSpeedMpS!=UNDEFINEDVALUE)
    Bolbro.updateItem("ESP32_Weatherbase_RawWindStrength", String(weatherPacket.mWindSpeedMpS, 1)+"m/s");
  Bolbro.updateItem("ESP32_Weatherbase_BatteryLevel", String(weatherPacket.batteryPercentage(), 0)+"%");
  Bolbro.updateItem("ESP32_Weatherbase_BatteryVoltage", String(weatherPacket.mBatteryVoltage, 2)+"V");
  Bolbro.updateItem("ESP32_Weatherbase_LastUpdate", Bolbro.openHABTime(lastPacketUpdate));  
}

//  main functions

void setup() 
{
  //  configure Bolbro
  Bolbro.setSerialBaud(115200l);
  Bolbro.addWiFi(SSID,PW); // customize
 
  Bolbro.addWANGateway(WAN); // customize or remove

  Bolbro.setOpenHABHost("openhabian"); // customize or remove
  Bolbro.setSignalStrengthItem("ESP32_Weatherbase_SignalStrength"); // customize or remove
  Bolbro.setLastStartItem("ESP32_Weatherbase_LastStart"); // customize or remove

  Bolbro.setup("Weatherbase", DEBUG, USEREMOTEDEBUG);

  Serial.println("Weather setup...");

  Bolbro.connectToWiFi();

  Bolbro.configureTime();

  //  restore station calibration settings
  calibrationPacket.restore();

  Serial.printf("Base setup...\n");

  //  setup LoRa connection
  HC12.begin();

  //  configure signaling LEDs
  pinMode(LED_PIN, OUTPUT);

  //  setup web server
  server.begin();
  Serial.println("HTTP server started");
}

void loop() 
{
  static unsigned long lastMillisLEDTurnedOn = 0;
  
  //  Handle requests to server
  server.handleClient();

  //  Handle input from station
  if (HC12.available()) {
    lastMillisLEDTurnedOn = millis();
    digitalWrite(LED_PIN, HIGH); // high when data is received
    if (weatherPacket.decodeByte(HC12.read())) {
      weatherPacket.printSerial();
      lastPacketUpdate = time(NULL);

      //  station is up currently, "return" calibration / configuration parameters
      sendCalibration();

      //  we have a verified set of data here, send it to homeautomation
      propagateToOpenHAB();
    }
  }

  //  Maintain LED status, turn off after 2 seconds of inactivity
  //  and blink in case the LED is off for longer than 3*SECONDS_BETWEEN_REPORTS
  unsigned long secondsPassed = (millis()-lastMillisLEDTurnedOn)/MS2S_FACTOR;

  if (secondsPassed>3*calibrationPacket.mSecondsBetweenReports)
    //  blink mode
    digitalWrite(LED_PIN, secondsPassed%2?HIGH:LOW);
  else if (secondsPassed>2)
    digitalWrite(LED_PIN, LOW); // low once no activity detected

  Bolbro.loop();
}
